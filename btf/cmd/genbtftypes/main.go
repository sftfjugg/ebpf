// Program gentypes reads a compressed vmlinux .BTF section and generates
// types from it.
//
// Output is written to "btf_gen_types.go".
package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/cilium/ebpf/btf"
	"github.com/cilium/ebpf/internal"
	"github.com/cilium/ebpf/internal/sys"

	"golang.org/x/exp/slices"
)

func main() {
	if err := run(os.Args[1:]); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
}

func run(args []string) error {
	if len(args) != 1 {
		return fmt.Errorf("expect location of compressed vmlinux .BTF as argument")
	}

	raw, err := internal.ReadAllCompressed(args[0])
	if err != nil {
		return err
	}

	spec, err := btf.LoadSpecFromReader(bytes.NewReader(raw))
	if err != nil {
		return err
	}

	output, err := generateTypes(spec)
	var fpe *failedPatchError
	if errors.As(err, &fpe) {
		fmt.Fprintf(os.Stderr, "  %v\n", fpe.Type)
		for _, member := range fpe.Type.Members {
			fmt.Fprintf(os.Stderr, "    %q %v\n", member.Name, member.Type)
		}
	}
	if err != nil {
		return err
	}

	w, err := os.Create("btf_gen_types.go")
	if err != nil {
		return err
	}
	defer w.Close()

	return internal.WriteFormatted(output, w)
}

func generateTypes(spec *btf.Spec) ([]byte, error) {
	typeID := &btf.Int{Size: 4}
	uint32T := &btf.Int{Size: 4, Encoding: btf.Unsigned}

	gf := &btf.GoFormatter{
		Names: map[btf.Type]string{
			typeID: internal.GoTypeName(sys.TypeID(0)),
		},
		Identifier: internal.Identifier,
		EnumIdentifier: func(name, element string) string {
			return element
		},
	}

	w := bytes.NewBuffer(nil)
	w.WriteString(`// Code generated by btf/cmd/genbtftypes; DO NOT EDIT.

package btf

`)

	// Assorted structs

	structs := []struct {
		goType  string
		cType   string
		patches []patch
	}{
		{
			"btfType", "btf_type",
			[]patch{
				flattenAnon,
				rename("size", "size_type"),
			},
		},
		{
			"btfEnum", "btf_enum",
			[]patch{
				replace(uint32T, "val"),
			},
		},
		{
			"btfArray", "btf_array",
			[]patch{
				replace(typeID, "type", "index_type"),
			},
		},
		{
			"btfMember", "btf_member",
			[]patch{
				replace(typeID, "type"),
			},
		},
		{
			"btfParam", "btf_param",
			[]patch{
				replace(typeID, "type"),
			},
		},
		{"btfVariable", "btf_var", nil},
		{
			"btfVarSecinfo", "btf_var_secinfo",
			[]patch{
				replace(typeID, "type"),
			},
		},
		{
			"btfDeclTag", "btf_decl_tag",
			[]patch{
				replace(uint32T, "component_idx"),
			},
		},
		{"btfEnum64", "btf_enum64", nil},
		{"btfHeader", "btf_header",
			[]patch{
				rename("str_off", "StringOff"),
				rename("str_len", "StringLen"),
			},
		},
	}

	sort.Slice(structs, func(i, j int) bool {
		return structs[i].goType < structs[j].goType
	})

	for _, s := range structs {
		fmt.Println("struct", s.goType)

		var t *btf.Struct
		if err := spec.TypeByName(s.cType, &t); err != nil {
			return nil, err
		}

		if err := outputPatchedStruct(gf, w, s.goType, t, s.patches); err != nil {
			return nil, fmt.Errorf("output %q: %w", s.goType, err)
		}
	}

	return w.Bytes(), nil
}

type failedPatchError struct {
	Type   *btf.Struct
	number int
	err    error
}

func (fpe *failedPatchError) Unwrap() error {
	return fpe.err
}

func (fpe *failedPatchError) Error() string {
	return fmt.Sprintf("patch %d: %v", fpe.number, fpe.err)
}

func outputPatchedStruct(gf *btf.GoFormatter, w *bytes.Buffer, id string, s *btf.Struct, patches []patch) error {
	s = btf.Copy(s, nil).(*btf.Struct)

	for i, p := range patches {
		if err := p(s); err != nil {
			return &failedPatchError{s, i, err}
		}
	}

	decl, err := gf.TypeDeclaration(id, s)
	if err != nil {
		return err
	}

	w.WriteString(decl)
	w.WriteString("\n\n")
	return nil
}

type patch func(*btf.Struct) error

func modify(fn func(*btf.Member) error, members ...string) patch {
	return func(s *btf.Struct) error {
		want := make(map[string]bool)
		for _, name := range members {
			want[name] = true
		}

		for i, m := range s.Members {
			if want[m.Name] {
				if err := fn(&s.Members[i]); err != nil {
					return err
				}
				delete(want, m.Name)
			}
		}

		if len(want) == 0 {
			return nil
		}

		var missing []string
		for name := range want {
			missing = append(missing, name)
		}
		sort.Strings(missing)

		return fmt.Errorf("missing members: %v", strings.Join(missing, ", "))
	}
}

func replace(t btf.Type, members ...string) patch {
	return modify(func(m *btf.Member) error {
		m.Type = t
		return nil
	}, members...)
}

func flattenAnon(s *btf.Struct) error {
	for i := range s.Members {
		m := &s.Members[i]

		if m.Type.TypeName() != "" {
			continue
		}

		var newMembers []btf.Member
		switch cs := m.Type.(type) {
		case *btf.Struct:
			for j := range cs.Members {
				cs.Members[j].Offset += m.Offset
			}
			newMembers = cs.Members

		case *btf.Union:
			cs.Members[0].Offset += m.Offset
			newMembers = []btf.Member{cs.Members[0]}

		default:
			continue
		}

		s.Members = slices.Replace(s.Members, i, i+1, newMembers...)
	}

	return nil
}

func rename(from, to string) patch {
	return func(s *btf.Struct) error {
		for i, m := range s.Members {
			if m.Name == from {
				s.Members[i].Name = to
				return nil
			}
		}
		return fmt.Errorf("no member named %q", from)
	}
}
